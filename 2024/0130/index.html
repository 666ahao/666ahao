<!DOCTYPE html>
<html>
<head><!-- hexo injector head_begin start --><script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- hexo injector head_begin end -->
  <meta charset="utf-8">
  
  <title>redis入门 | 沧海一粟</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="redis是一个开源的key-value存储系统，支持多种value类型以及丰富的操作，并支持原子性操作，数据可以保存在缓存中，支持数据持久化，周期性写入磁盘记录，单线程多路IO复用，能够实现主从同步，适合高并发、海量数据读写">
<meta property="og:type" content="article">
<meta property="og:title" content="redis入门">
<meta property="og:url" content="http://openkit.gitee.io/2024/0130/index.html">
<meta property="og:site_name" content="沧海一粟">
<meta property="og:description" content="redis是一个开源的key-value存储系统，支持多种value类型以及丰富的操作，并支持原子性操作，数据可以保存在缓存中，支持数据持久化，周期性写入磁盘记录，单线程多路IO复用，能够实现主从同步，适合高并发、海量数据读写">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-01-30T09:16:09.000Z">
<meta property="article:modified_time" content="2024-03-10T03:22:17.491Z">
<meta property="article:author" content="沧海一粟">
<meta property="article:tag" content="沧海一粟">
<meta property="article:tag" content="openkit">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
 <!-- <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>-->
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

<meta name="generator" content="Hexo 6.3.0"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="沧海一粟" rel="home"> 沧海一粟 </a>
            
          </h1>
          
          
            <div class="site-description">自律,坚持,谦卑,进取</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="/"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="archives"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="categories"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="tags"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="about"> <a class="" href="/about">关于</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="friends"> <a class="" href="/friends">友链</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-redis入门" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      redis入门
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2024/0130/" class="article-date">
	  <time datetime="2024-01-30T09:16:09.000Z" itemprop="datePublished">一月 30, 2024</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/">缓存中间件</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>redis是一个开源的key-value存储系统，支持多种value类型以及丰富的操作，并支持原子性操作，数据可以保存在缓存中，支持数据持久化，周期性写入磁盘记录，单线程多路IO复用，能够实现主从同步，适合高并发、海量数据读写<span id="more"></span>。</p>
<p>最新版7.2.4 <a target="_blank" rel="noopener" href="https://redis.io/download/">redis官网下载</a></p>
<p>将下载的压缩包在linux下解压安装，安装目录&#x2F;usr&#x2F;local&#x2F;bin，安装目录下</p>
<p>redis-benchmark：性能测试工具</p>
<p>redis-check-aof：修复aof文件</p>
<p>redis-check-dump：修复dump.rdb文件</p>
<p>redis-sentinel：redis集群工具</p>
<p>redis-server：服务器启动命令</p>
<p>例·：<code>redis-server /etc/redis.conf</code></p>
<p>redis-cli：客户端连接，默认连接本地</p>
<p>默认端口：6379 </p>
<p>默认0-15数据库，16个数据库，所有库密码统一</p>
<h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p>前台启动：redis-server、redis-cli</p>
<p>远程执行命令：<code>redis-cli -h host -p port -a password</code></p>
<p>关闭命令：redis-cli shutdown或进入redis后shutdown</p>
<p><code>keys *</code>，参考当前库所有key</p>
<p><code>exsits key</code>，判断某个key是否存在，1存在，0不存在</p>
<p><code>type key</code>，参考key的类型</p>
<p><code>del key</code>，删除指定key的数据</p>
<p><code>unlink key</code>，根据key异步删除，即可能不会立刻删除</p>
<p><code>expire key 10</code>，为key设置过期时间，10秒后无法取值</p>
<p><code>ttl key</code>，查看key还有多少秒过期-1永不过期，-2已过期</p>
<p><code>dbsize</code>，查看当前数据库的key数量</p>
<p><code>set &lt;key&gt; &lt;value&gt;</code>，设置key-value</p>
<p><code>get key</code>，获取value</p>
<p><code>setnx &lt;key&gt; &lt;value&gt;</code>，当key不存在时设置键值对。</p>
<p><code>append &lt;key&gt; &lt;value&gt;</code>，追加value到指定key的值后，返回长度。</p>
<p><code>strlen key</code>，获取值的长度。</p>
<p><code>incr key</code>，将key中存贮的数字值加1</p>
<p><code>decr key</code>，将key中存贮的数字值减1</p>
<p><code>incrby key 100</code>，将key中存贮的数字值加100</p>
<p><code>decrby key 100</code>，将key中存贮的数字值减100</p>
<p><code>mset k1 v1 k2 v2..</code>，设置多个键值对（原子性）。</p>
<p><code>msetnx k1 v1 k2 v2..</code>，同时设置多个键值对，仅当给定key都不存在（原子性）</p>
<p><code>mget &lt;key1&gt; &lt;key2&gt;..</code>，获取多个value（原子性）。</p>
<p><code>getrange key &lt;起始位置&gt; &lt;结束位置&gt;</code>，根据key获取value的某段范围（前包后包）</p>
<p><code>setrange key &lt;index&gt; value</code>，用value覆写key对应的值，从index开始</p>
<p><code>setex key &lt;过期时间&gt; value</code>，设置键值的同时，过期时间单位秒</p>
<p><code>getset key value</code>，先根据key获取值，然后设置新值value</p>
<p><code>select &lt;dbid&gt;</code>，切换数据库</p>
<p><code>flushdb</code>，清除当前库</p>
<p><code>flushall</code>，清楚全部库</p>
<p>redis设置密码：</p>
<p><code>config set requirepass &quot;123456&quot;</code></p>
<p><code>auth 123456</code>密码认证</p>
<p>redis获取密码：<code>config get requirepass </code></p>
<h4 id="五大基本数据类型"><a href="#五大基本数据类型" class="headerlink" title="五大基本数据类型"></a>五大基本数据类型</h4><h5 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h5><p>它是最基本的类型。可以包含任何数据，是二进制安全的。它是一种动态的字符串，采用预分配冗余空间减少内存消耗，当超出分配空间时成倍扩容，一个字符串value最多可以是512M。</p>
<h5 id="列表List"><a href="#列表List" class="headerlink" title="列表List"></a>列表List</h5><p>底层为双向链表，按照插入顺序排序，是简单的字符串列表。数据结构为quickList，在元素较少时压缩列表。</p>
<p><code>lpush/rpush k v1 v2.. </code>，从左边&#x2F;右边插入一个或多个值。</p>
<p><code>lpop/rpop key</code>，从左&#x2F;右取出（返回并删除）一个值。（当没有值时该键消失）</p>
<p><code>rpoplpush &lt;key1&gt; &lt;key2&gt;</code>，从key1列表的右边吐出一个值插入key2列表的左边。</p>
<p><code>lrange &lt;key&gt; &lt;first&gt; &lt;last&gt;</code>，根据key按照下标取值，从左到右first-last。例lrange k1 0 -1。</p>
<p><code>lindex key index</code>，根据key从左到右，获取下标为index的value值。</p>
<p><code>llen key</code>，获取列表长度。</p>
<p><code>linsert &lt;key&gt; before/after &lt;value&gt; &lt;newvalue&gt;</code> ，从左到右根据key在value前或后插入新值。</p>
<p><code>lrem &lt;key&gt; n &lt;value&gt;</code>，从左到右根据key删除列表中前n个value</p>
<p><code>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</code>，从左到右根据key，为下标index的位置设置value</p>
<h5 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h5><p>数据结构是dict字典，使用哈希表实现，不允许重复元素，是一个无序集合。</p>
<p><code>sadd key &lt;v1&gt; &lt;v2&gt;..</code>，将一个或多个值存入key集合。</p>
<p><code>smembers key</code>，列出集合key中的所有值。</p>
<p><code>sismembers key value</code>，判断集合key中是否有value，有1，没有0.</p>
<p><code>scard key</code>，返回集合key元素个数。</p>
<p><code>srem key &lt;v1&gt; &lt;v2&gt;..</code>，删除集合key中一个或多个value</p>
<p><code>spop key</code>，随机从集合key中返回一个value值。</p>
<p><code>srandmember key n</code> ，随机从集合中返回个值。</p>
<p><code>smove k1 k2 value</code>，将value从k1移动到k2。</p>
<p><code>sinter k1 k2</code>，返回两个的交集。</p>
<p><code>sunion k1 k2</code>，返回两个集合的并集。</p>
<p><code>sdiff k1 k2</code>，返回差集，在k1中，不在k2的</p>
<h5 id="哈希Hash"><a href="#哈希Hash" class="headerlink" title="哈希Hash"></a>哈希Hash</h5><p>键值对集合，string类型的field字段和value的映射表，field建赋值value，则redis数据库表示为<code>key：映射表</code>，其中key为。对应数据结构为ziplist和hashtable。</p>
<p><code>hset key field value</code>，给key中field键设置value值。</p>
<p>例：hset user:001 id 1</p>
<p><code>hsetnx key field value</code>，当field不存在时，给key中field键设置value值。</p>
<p><code>hget key field</code>，获取key中field键的值。</p>
<p><code>hmset key f1 v1 f2 v2..  </code>，给key中多个field键设置value值。</p>
<p><code>hexists key field</code>，查看key集合中field字段是否存在。</p>
<p><code>hkeys key</code>，列出key集合中所有field。</p>
<p><code>hvals key</code>，列出集合中所有value。</p>
<p><code>hincrby key field n</code>，为key中field的value值加n。</p>
<h5 id="有序集合Zset"><a href="#有序集合Zset" class="headerlink" title="有序集合Zset"></a>有序集合Zset</h5><p>有序集合，集合中元素不可重复，但是集合中每一个value都有一个score指标，需要设置并以此排序。底层使用了两种数据结构：hash表，value为score；跳跃表，快速获取元素。</p>
<p><code>zadd key score1 value1 score2 value2..</code>，将一个或多个value及其score值加入到key中。</p>
<p><code>zrange key first last [withscores]</code>，返回有序集合key中，下标在[first,last]间的value，可以带上score。</p>
<p><code>zrangebyscore key min max [withscores] [limit offset count]</code>，返回集合中score值在[min.max]区间的value，且默认按从小到大输出。</p>
<p><code>zrevrangebyscore key max min [withscores] [limit offset count]</code>，同上，从大到小输出。</p>
<p><code>zincrby key n value</code> ，给元素value的score值增加n。</p>
<p><code>zrem key value</code>，删除key集合下value值。</p>
<p><code>zcount key smin smax</code>，统计集合中元素的score在[smin,smax]区间的个数。</p>
<p><code>zrank key value</code>，返回集合中值value的下标。</p>
<p>例：</p>
<p>1）zadd level  100 Lv1 80 Lv2  50 Lv3</p>
<p>2）zrange level 0 -1</p>
<p>3）zrangebyscore  level  0 80 withscores</p>
<h5 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h5><p><strong>Bitmaps</strong></p>
<p>Bitmaps可实现对位bit的操作，但实际是可以操作位的字符串，把存储位的字符串看作动态数组，则数组下标为offset偏移量，数组中的元素为比特0&#x2F;1，默认全部为0。适合存储大量访问数据，节省空间。</p>
<p><code>setbit key offset value</code>，设置名为key的Bitmaps中偏移量offset上的位为value（0或1），偏移量过大影响性能。</p>
<p><code>getbit key offset</code>，获取下标为offset上的value值。</p>
<p><code>bitcount key</code>，统计该Bitmaps中bit为1的数量，默认全范围，按字节单位统计。</p>
<p><code>bitcount key start end</code>，统计该Bitmaps中bit为1的数量，范围为从第start个字节组开始，到第end个字节。</p>
<p><code>bitop and k1 k2 k3..</code>，对k2,k3多个Bitmaps做交集运算，结果保存至k1。此外bitop还可以进行or并集、not非、xor异或运算。</p>
<p>例：<code>setbit user:202401027 0 1</code></p>
<p><strong>HyperLogLog</strong></p>
<p>根据输入的元素计算基数，即集合中不重复的元素，但不存储元素。</p>
<p><code>pfadd key element1 element2..</code>，添加元素element1，element2多个元素到集合中。</p>
<p><code>pfcount key..</code>，统计一个或多个集合中的基数，为多个key时合并元素再统计基数。</p>
<p><code>pfmerge dkey skey1 skey2..</code>，将skey1、skey2等多个集合合并放入dkey集合中。</p>
<p><strong>Geospatial</strong></p>
<p>提供了对地点的二维坐标的存储、查询、hash等操作。</p>
<p><code>geoadd key 经度 纬度 地点名</code>，以经纬度添加地点位置，可添加多个地点。</p>
<p>例：<code>geoadd china:city 121.47 31.23 shanghai</code></p>
<p><code>geopos key 地点名</code>，从key集合中获取某地点位置。</p>
<p><code>geodist key 地点1 地点2 [m/km/ft]</code>，获取两个地点的直线距离，默认单位m米。</p>
<p><code>georadius key 经度 纬度 半径 [m/km/ft]</code>，以给定经纬度的地点为中心，在key中找出在半径内地点城市。</p>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>1）Units单位<br>配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感。</p>
<p>2）INCLUDES包含</p>
<p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<p>3）网络相关配置bind</p>
<p>默认情况bind&#x3D;127.0.0.1只能接受本机的访问请求，不写的情况下，无限制接受任何ip地址的访问。生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，所以需要将其注释掉。如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应。</p>
<p>4）protected-mode<br>将本机访问保护模式设置no，默认是yes即开启。设置外部网络连接redis服务，设置方式如下：</p>
<p> 关闭protected-mode模式，此时外部网络可以直接访问。</p>
<p> 开启protected-mode保护模式，需配置bind ip或者设置访问密码。</p>
<p>5）Port</p>
<p>端口号，默认 6379。</p>
<p>6）tcp-backlog</p>
<p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握手队列 + 已经完成三次握手队列。在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p>
<p>7）timeout</p>
<p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能，即永不关闭。</p>
<p>8）tcp-keepalive</p>
<p>对访问客户端的一种心跳检测，每隔n秒检测一次。单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60。默认是300秒检查一次，即如果300秒，没有做任何操作，那么便会释放当前连接。</p>
<p>9）daemonize</p>
<p>是否为后台进程，设置为yes，默认为no，需要手动更改，守护进程，后台启动。</p>
<p>10）pidfile</p>
<p>存放pid文件的位置，每个实例会产生一个不同的pid文件，每次操作，都会有进程号，pidfile负责保存这些进程号。</p>
<p>11）loglevel</p>
<p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice，四个级别根据使用阶段来选择，生产环境选择notice或者warning。</p>
<p>12）logfile</p>
<p>设置日志的输出文件路径，默认为空。</p>
<p>13）databases 16</p>
<p>设定库的数量默认16，默认数据库为0，可以使用SELECT &lt; dbid &gt;命令在连接上指定数据库id。</p>
<p>14）SECURITY安全</p>
<p>设置密码，<code># requirepass foobared</code>默认没有密码。在命令中设置密码，只是临时的，重启redis服务器，密码就还原了。永久设置，需要再配置文件中进行设置。</p>
<p>15）maxclients</p>
<p>设置redis同时可以与多少个客户端进行连接，默认情况下为10000个客户端。如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p>
<p>16）maxmemory</p>
<p>必须设置，否则将内存占满，造成宕机。设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息。</p>
<p>对于无内存申请的指令，仍然会正常响应，比如GET等。如果redis是主redis，那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<p>17）maxmemory-policy</p>
<p>volatile-lru：使用LRU算法移除key，只针对设置了过期时间的键（最近最少使用）。<br>allkeys-lru：在所有集合key中，使用LRU算法移除key。<br>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键。<br>allkeys-random：在所有集合key中，移除随机的key。<br>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key<br>noeviction：不进行移除，针对写操作，只是返回错误信息。</p>
<p>18）maxmemory-samples</p>
<p>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_53157173/article/details/119728428">参考文章：Redis6—配置文件篇</a></p>
<h4 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h4><p>发布和订阅是一种消息通信模式，发布者向一个channel频道发布信息，订阅这个频道的订阅者接收信息。</p>
<p>打开一个redis客户端：</p>
<p><code>subscribe c1</code></p>
<p>打开另一个客户端：</p>
<p><code>publish c1 helloredis</code></p>
<p>订阅的客户端将收到helloredis消息。若消息没有持久化，则订阅的客户端只能收到订阅后的消息。</p>
<h4 id="Jedis操作Redis"><a href="#Jedis操作Redis" class="headerlink" title="Jedis操作Redis"></a>Jedis操作Redis</h4><p>Jedis是redis的java版本的客户端实现，使用Jedis提供的Java API对Redis进行操作，并且使用Jedis提供的对Redis的支持灵活全面，但编码复杂度较高。</p>
<p>1）导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）创建对象测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);<span class="comment">//host port</span></span><br><span class="line">System.out.println(jedis.ping());</span><br><span class="line"><span class="comment">//配置文件中protected-mode:no,注释掉bind</span></span><br></pre></td></tr></table></figure>

<p>3）设置键值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三疯了&quot;</span>);</span><br><span class="line">jedis.mset(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line">jedis.incr(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">System.out.println(jedis.mget(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;sex&quot;</span>, <span class="string">&quot;age&quot;</span>));</span><br></pre></td></tr></table></figure>



<p>具体可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_61910385/article/details/123572225">jedis相关详解</a></p>
<h4 id="springboot整合redis"><a href="#springboot整合redis" class="headerlink" title="springboot整合redis"></a>springboot整合redis</h4><p>SpringBoot 的自动装配机制会自动的创建一些对象来方便我们操作 Redis：</p>
<ul>
<li><code>RedisConnectionFactory</code>，根据指定的配置来获取 Redis 连接的</li>
<li><code>RedisTemplate</code>、<code>StringRedisTemplate</code>，用来操作 Redis 存取数据。</li>
</ul>
<p>1）导入spring-data-redis和commons-pool2连接池依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从 SpringBoot2.x 开始，默认使用 Lettuce 作为 Spring Data Redis 的内部实现，而不是 Jedis。</p>
<p>2）在核心配置文件中配置redis</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">xxx</span></span><br></pre></td></tr></table></figure>



<p>3）声明配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> extend CachingConfigureSupport&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">// 定义 String 序列化器</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 定义 Jackson 序列化器</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">//反序列化时智能识别变量名（识别没有按驼峰格式命名的变量名）</span></span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">//反序列化识别对象类型</span></span><br><span class="line"><span class="comment">//        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span></span><br><span class="line">        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line">        <span class="comment">//反序列化如果有多的属性，不抛出异常</span></span><br><span class="line">        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//反序列化如果碰到不识别的枚举值，是否作为空值解释，true:不会抛不识别的异常, 会赋空值，false:会抛不识别的异常</span></span><br><span class="line">        objectMapper.configure(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL, <span class="literal">true</span>);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        <span class="comment">// 设置Redis的key以及 hash 结构的 field 使用 String 序列化器</span></span><br><span class="line">        redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// 设置Redis的value 以及 hash 结构的value使用 Jackson 序列化器</span></span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redis&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置键值对</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">        String v1= redisTemplate.opsForValue().get(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        System.out.println(v1);</span><br><span class="line">        redisTemplate.opsForSet().add(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isMember</span> <span class="operator">=</span> redisTemplate.opsForSet().isMember(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        redisTemplate.opsForList().leftPush(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        redisTemplate.opsForList().leftPush(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) redisTemplate.opsForList().rightPop(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb6fb8f8bb83">SpringBoot 整合 Redis</a></p>
<h4 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h4><p>redis事务是单独的事务操作，事务中的命令会按顺序执行，且不会被打断。</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>
</ul>
<p><strong>事务开启</strong></p>
<p>1）<code>multi</code></p>
<p>输入后开启事务，将要执行的命令逐一输入命令行，若出现error，则事务不会执行成功。</p>
<p>2）<code>exec</code></p>
<p>逐一执行事务的命令，其中一条执行出错不影响其他命令执行成功，期间不被其他命令中断。</p>
<p>3）<code>discard</code></p>
<p>中止事务，在输入事务命令的期间可以放弃事务。</p>
<p>解决事务冲突方式：悲观锁（操作前先上锁操作后在开锁）；乐观锁（给数据添加版本号，每次迭代不同版本，判断数据是否更改，适合读较多的场景）。redis采用check-and-set乐观锁机制解决事务冲突。</p>
<p><strong>watch数据监视</strong></p>
<p><code>watch key..</code>，在开启事务multi前，监视一个或多个key，如果事务执行前这些key被其他命令改动则事务将中断。</p>
<p><code>unwatch key..</code>，取消所有key的监视。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; WATCH lock lock_times</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; UNWATCH</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>



<p><strong>redis事务的三个特性</strong></p>
<p>1）单独的隔离操作</p>
<p>事务中的命令都会序列化，按顺序执行，事务执行中不会其他客户端命令打断。</p>
<p>2）没有隔离级别的操作</p>
<p>事务在提交前，任何指令都不会执行。</p>
<p>3）不保证原子性</p>
<p>事务中有一条命令执行失败，不影响其他命令执行，没有回滚。</p>
<h4 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis 脚本"></a>Redis 脚本</h4><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong>。</p>
<p><strong>语法</strong></p>
<p>Eval 命令的基本语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EVAL script numkeys key [key ...] <span class="built_in">arg</span> [<span class="built_in">arg</span> ...]</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<p>以下实例演示了 redis 脚本工作过程：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EVAL <span class="string">&quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot;</span> <span class="number">2</span> key1 key2 first second</span><br><span class="line">	</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;key1&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;key2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;first&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;second&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>脚本命令</strong></p>
<p>下表列出了 redis 脚本常用命令：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">EVAL script numkeys key [key …] arg [arg …] 执行 Lua 脚本。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">EVALSHA sha1 numkeys key [key …] arg [arg …]执行 Lua 脚本。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">SCRIPT EXISTS script [script …]查看指定的脚本是否已经被保存在缓存当中。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SCRIPT FLUSH从脚本缓存中移除所有脚本。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">SCRIPT KILL杀死当前正在运行的 Lua 脚本。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">SCRIPT LOAD script将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td>
</tr>
</tbody></table>
<h4 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h4><p><strong>SAVE</strong> 命令用于创建当前数据库的备份。</p>
<h5 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h5><p>Save 命令基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SAVE </span><br></pre></td></tr></table></figure>

<p>该命令将在 redis 安装目录中创建dump.rdb文件。</p>
<h5 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h5><p>如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并重新启动服务即可。获取 redis 目录可以使用 <strong>CONFIG</strong> 命令，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET dir</span><br><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;/usr/local/redis/bin&quot;</span><br></pre></td></tr></table></figure>

<p>以上命令 <code>CONFIG GET dir </code>输出的 redis 安装目录为 &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin。</p>
<h5 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h5><p>创建 redis 备份文件也可以使用命令 <strong>BGSAVE</strong>，该命令在后台执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bgsave</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>



<h5 id="持久化的三种方式"><a href="#持久化的三种方式" class="headerlink" title="持久化的三种方式"></a>持久化的三种方式</h5><p><strong>（1）RDB</strong></p>
<p>快照持久化，redis一种数据持久化的方式，默认通过fork子进程创建一个临时文件，把临时文件再替换成持久化文件dump.rdb(在redis启动目录下)，在指定的时间间隔内将内存中的数据快照写入磁盘，这种技术为<u>写时复制</u>。</p>
<p>快照持久化是 <u>Redis 默认采用的持久化方式</u>，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1  #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line">save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><br><span class="line">save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照</span><br></pre></td></tr></table></figure>

<p>关闭rdb命令: <code>config set save &quot;&quot;</code></p>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程。</li>
<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，<u>默认选项</u>。</li>
</ul>
<p>这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。</p>
<p>优点：高效，恢复速度快，适合大规模数据操作。</p>
<p>缺点：当服务器宕机时，最后一次备份数据可能丢失。</p>
<p><strong>（2）AOF</strong></p>
<p>以日志形式记录每次的写操作指令，只能追加到aof文件但不可改写文件，redis启动时会读取该文件完成数据恢复。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了）。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code>。可以在配置文件中通过 <code>appendonly</code> 参数开启或通过<code>config set appendonly &quot;yes&quot;</code>命令开启：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p><u>RDB和AOF同时开启默认取AOF文件的数据</u>，两种数据备份和恢复操作相似。</p>
<p><strong>异常恢复</strong>：</p>
<p>如果aof文件损坏，可以通过<code>redis-check-aof --fix appendonly.aof</code>恢复，之后重启redis。</p>
<p><strong>AOF同步频率</strong>：</p>
<p>appendfsync always：始终同步，每次写入都会记录日志，性能差但数据完整性好。</p>
<p>appendfsync everysec：每秒记录一次日志，最后一秒的数据可能丢失。</p>
<p>appendfsync  no：不主动同步，记录交给主机。</p>
<p><strong>Rewrite压缩</strong></p>
<p>为避免文件越来越大，当文件超出预定大小，redis就会启动aof文件压缩，只保留恢复数据的最小指令集，可以使用<code>bgrewriteaof</code>命令。重写就是把rdb的快照以二进制附在aof文件头部，作为新数据替换到原来数据，从而覆盖aof文件。</p>
<p>在配置文件中可以设置触发rewrite的值：</p>
<p><code>auto-aof-rewrite-percentage</code>：文件大小&gt;&#x3D;重写前文件的大小basesize + basesize*百分之多少。</p>
<p><code>auto-aof-rewrite-min-size</code>：当文件达到这个最小值rewrite。</p>
<p><strong>AOF执行流程</strong>：开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式的策略来决定何时将系统内核缓存区的数据同步到硬盘中的。只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险。</p>
<p>优点：丢失数据概率低，可以处理误操作</p>
<p>缺点：占用空间，备份慢，每次同步有性能压力。</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/646362807">Redis持久化机制 RDB、AOF、混合持久化详解！如何选择？</a></p>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主机数据更新后，根据配置策略自动同步备机中，形成master-slave机制，主机以写操作为主，从机以读为主，达到读写分离。</p>
<p>复制原理：</p>
<p>1）当从服务器连上主服务器后，向主服务器发送数据同步请求</p>
<p>2）主服务器收到请求进行数据持久化操作，把rdb文件发送到从服务器，从服务器进行读取</p>
<p>3）每次主服务器进行写操作后，会主动同步数据到从服务器</p>
<h5 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h5><p>1）根据主机配置文件创建从机的配置文件，分别为redis6380.conf、redis6381.conf，分别写入：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">include</span> <span class="string">/etc/redis.conf</span></span><br><span class="line"><span class="attr">pidfile</span> <span class="string">/var/run/redis_6380.pid</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6380</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump6380.rdb</span></span><br></pre></td></tr></table></figure>

<p>关闭aof，将6379改为从机的6380、6381。</p>
<p>2）根据配置文件启动redis主机及其从机</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br><span class="line">redis-server /etc/redis6380.conf</span><br><span class="line">redis-server /etc/redis6381.conf</span><br></pre></td></tr></table></figure>

<p>此时主机与从机相互独立，没有从属关系。</p>
<p>3）分别进入从机的redis客户端，输入以下命令即可建立关系：</p>
<p><code>slaveof 主机ip 主机端口</code></p>
<p>解除关系(反客为主)：从机<code>slaveof no one</code></p>
<p>使用<code>info replication</code>命令可以看到从属关系，从机上只能读不允许写操作，主机上进行写操作后，从机上也能看到数据。</p>
<p>注意：从机宕机后会变回master主服务器，需要再次绑定关系，而主服务器宕机后再重启还是主服务器，从机还是从机。</p>
<h5 id="代代相传"><a href="#代代相传" class="headerlink" title="代代相传"></a>代代相传</h5><p>上一个slave可以是下一个slave的master，从而形成一条数据同步链。同样使用<code>slaveof</code>命令建立关系，但是中途变更从属关系会失去之前同步的数据而重新拷贝最新的数据。</p>
<p>注意：当某个slave宕机了，后面的slave将无法获取备份数据。</p>
<h5 id="哨兵模式sentinel"><a href="#哨兵模式sentinel" class="headerlink" title="哨兵模式sentinel"></a>哨兵模式sentinel</h5><p>自动反客为主，设置一个哨兵服务器后台监控主机状态，若主机故障根据投票将某从机变为主机。</p>
<p>1）配置哨兵服务器</p>
<p>新建一个配置文件sentiel.conf，内容为：</p>
<p><code>sentinel monitor MyMaster 127.0.0.1 6379 1</code></p>
<p>其中MyMaster为监控对象名称，即主服务器的别名，127.0.0.1为主服务器ip，6379为端口号，1为同意数据迁移的哨兵数量。</p>
<p>2）启动哨兵	</p>
<p><code>redis-sentinel sentinel.conf</code></p>
<p><strong>哨兵策略</strong>：</p>
<p>从下线的主服务器的从服务器中挑选一个转为主服务器，主机选取策略依次为：选取优先级高的、选取偏移量最大的、选runid最小的。选取主服务器后，向原来的其他从服务器发送slaveof，复制新的master，当已下线的旧主服务器重新上线时，sentinel会发送slaveof命令使其变为从服务器。</p>
<p>注意：配置中replica-priority越小，优先级越高。偏移量最大表示数据越全！</p>
<h4 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h4><p>实现对redis的水平扩容（启动N个节点，每个节点存储总数据的N分之一），通过分区partition提供可用性，即使节点失效，集群也可以继续处理请求。无中心化集群，任何一个节点都能接收请求，解决容量不够，并发写操作。</p>
<h5 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h5><p>1）删除之前的持久化数据rdb,aof</p>
<p>2）制作6个实例，6379，6380，6381，6389，6390，6391，集群至少6个节点！</p>
<p>配置各个实例配置文件，redis6379.conf：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">include</span> <span class="string">/etc/redis.conf</span></span><br><span class="line"><span class="comment">#打开集群模式</span></span><br><span class="line"><span class="attr">cluster-enabled</span> <span class="string">yes</span></span><br><span class="line"><span class="comment">#集群配置文件</span></span><br><span class="line"><span class="attr">cluster-config-file</span> <span class="string">nodes-6379.conf</span></span><br><span class="line"><span class="comment">#节点超时时间，单位毫秒，超过该时间自动进行主从切换</span></span><br><span class="line"><span class="attr">cluster-node-timeout</span> <span class="string">15000</span></span><br><span class="line"><span class="comment">#若某一主从节点都挂掉，那整个集群继续工作，设为yes则集群停止工作</span></span><br><span class="line"><span class="attr">cluster-require-full-coverage</span> <span class="string">no</span></span><br><span class="line"><span class="attr">pidfile</span> <span class="string">/var/run/redis_6379.pid</span></span><br><span class="line"><span class="comment">#客户端连接端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment">#配置节点的总线端口（节点之间通信的端口，注意必须与节点客户端端口不同，若port=6380,总线端口16380）</span></span><br><span class="line"><span class="attr">cluster-announce-bus-port</span> <span class="string">16379</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump6379.rdb</span></span><br><span class="line"><span class="attr">Appendonly</span> <span class="string">no</span></span><br><span class="line"><span class="comment">#后台启动</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"><span class="comment">#保护模式，开启为yes需要密码</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>

<p>在vim编辑下，快速查找替换命令<code>%s /6379/6380</code></p>
<p>3）启动6个redis服务器</p>
<p><code>redis-server redis6379.conf </code></p>
<p><code>redis-server redis6380.conf ..</code></p>
<p>4）将6个节点合并</p>
<p><u>需要ruby环境，进入redis安装目录src下执行命令</u></p>
<p><code>redis-cli --cluster create --cluster-replicas 1 localhost:6379 localhost:6380.. </code></p>
<p>其中localhost可替换为真实ip地址，–cluster集群操作。–replicas 1采用最简单方式配置（1台从节点），一台主机一台从机，将分配三个主节点，三个从节点。</p>
<p>5）此时waiting for the cluster  to join…</p>
<p>需要进入各个节点客户端进行集群通信的建立，<code>redis-cli -c -h localhost -p 6379</code>，进入后执行<code>cluster meet 192.168.56.3 16379 16379</code>，结果输出ok则成功。其他节点类似，执行<code>cluster meet 节点ip  节点总线端口  公共总线端口</code>，如<code>cluster meet 192.168.56.3 16380 16379</code>，注意上述端口一定要能访问，要通过防火墙开放。</p>
<p>6）上述6个节点弄完后集群测试</p>
<p><code>redis-cli -c -h [ip] -p 6379</code></p>
<p>查看集群节点信息：<code>cluster nodes</code>，若集群节点信息输出成功！</p>
<p>7）存入键值</p>
<p><code>set k1 v1</code></p>
<p>注意不在一个插槽范围(节点)的键不能使用mset、mget操作，需要{}分组放入：</p>
<p><code>mset k1&#123;c1&#125; v1 k2&#123;c1&#125; v2 k3&#123;c1&#125; v3</code></p>
<p>以c1组名作为key放入节点。</p>
<p><strong>slot插槽</strong></p>
<p>一个redis集群会包含16384个插槽，数据库中的每个键都属于其中一个插槽。在存入key-value时，集群使用CRC(key)%16384计算key属于哪个插槽，集群中每个主节点会负责一部分插槽的管理，这样可以让key分配到合适的节点中。</p>
<h5 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h5><p><code>cluster keyslot key</code>，查询集群中key所在的插槽位置。</p>
<p>例：cluster keyslot c1</p>
<p><code>cluster countkeysinslot 3344</code>，统计插槽3344中key的个数，只能看所在插槽(节点)的key。</p>
<p><code>cluster getkeysinslot &lt;slot&gt; &lt;count&gt;</code>，返回count个在插槽slot中的key，只能看所在插槽(节点)的key。</p>
<p>例：cluster getkeysinslot 3344  520</p>
<p><code>mget c1</code>，返回c1的value，只能看所在插槽(节点)的数据。</p>
<h5 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h5><p>当某节点的主机故障时，从机将变为主机master，原主机将恢复为从机。若某一主从节点都挂掉，那整个集群能不能继续工作看配置，<code>cluster-require-full-coverage</code>设为yes则整个集群停止工作。</p>
<h5 id="Jedis操作集群"><a href="#Jedis操作集群" class="headerlink" title="Jedis操作集群"></a>Jedis操作集群</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HostAndPort</span> <span class="variable">hostandport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(hostandport);</span><br><span class="line">jedisCluster.set(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>);</span><br><span class="line">System.out.println(jediSCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br></pre></td></tr></table></figure>



<h4 id="应用问题"><a href="#应用问题" class="headerlink" title="应用问题"></a>应用问题</h4><h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>查询一个<u>缓存中和数据库中都不存在的数据</u>，导致每次查询这条数据都会透过缓存，直接查库返回空，造成大量数据请求访问数据库，数据库无法同步缓存，使服务器崩溃。</p>
<p>解决：</p>
<p>1）对空值缓存，设置其过期时间</p>
<p>2）使用bitmaps设置白名单</p>
<p>3）布隆过滤器BloomFilter（底层bitmaps）</p>
<p>4）缓存预热</p>
<h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>指当缓存中<u>某个热点数据过期了</u>，在该热点数据重新载入缓存之前，有大量的查询请求穿过缓存，直接查询数据库。这种情况会导致数据库压力瞬间骤增，造成大量请求阻塞，甚至直接挂掉。</p>
<p>解决：</p>
<p>1）预先设置热门key，将某些热点数据的过期时间设为无限，预加载热点数据。</p>
<p>2）使用分布式锁，在获取数据时，使用分布式锁来控制只有一个是请求可以去后端获取数据，其他请求需要等待锁释放，这种方法可以有效防止多个请求同时穿透到后端存储系统。</p>
<h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>指当缓存中有<u>大量的key在同一时刻过期或者Redis缓存直接宕机了</u>，导致大量的查询请求全部到达数据库，造成数据库查询压力骤增，甚至直接挂掉。</p>
<p>解决：</p>
<p>1）针对第一种大量key同时过期的情况，只需要将每个key的过期时间打散即可，使它们的失效点尽可能均匀分布。</p>
<p>2）针对第二种redis发生故障的情况，部署redis时可以使用redis的几种高可用方案部署，例如构建多级缓存、集群和哨兵模式。</p>
<p>3）设置过期标志更新缓存，限流。</p>
<p>4）分布式锁。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/628484809">缓存失效的三大祸害：穿透、击穿、雪崩及应对策略详解</a></p>
<h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。</p>
<p>特征：互斥性、锁超时释放、可重入性、高性能和高可用、原子性‘。</p>
<p>实现的几种方式：</p>
<p>1）setnx+expire</p>
<p>setnx上锁，del释放锁，expire设置锁自动释放时间，缺点是不是原子操作。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setnx <span class="built_in">users</span> 10</span><br><span class="line">expire <span class="built_in">users</span> 60</span><br><span class="line">del <span class="built_in">users</span></span><br></pre></td></tr></table></figure>

<p>2）<code>set key value nx ex seconds</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">users</span> 10 nx ex 60</span><br></pre></td></tr></table></figure>

<ul>
<li>nx : 表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。</li>
<li>ex seconds : 设定key的过期时间，时间单位是秒。</li>
<li>px milliseconds:  设定key的过期时间，单位为毫秒</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key_resource_id, lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">  &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      jedis.del(key_resource_id); <span class="comment">//释放锁</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用UUID解决误删问题：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//uuid表示不同的操作</span><br><span class="line"><span class="built_in">set</span> lock uuid nx ex 60</span><br><span class="line">//释放锁时判断当前uuid与要释放锁的uuid是否一致</span><br></pre></td></tr></table></figure>

<p>3）使用Lua脚本</p>
<p>使用Lua脚本来保证操作的原子性（包含setnx和expire两条指令），脚本内容如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">   redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>加锁代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">lua_scripts</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +</span><br><span class="line">            <span class="string">&quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;   </span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));</span><br><span class="line"><span class="comment">//判断是否成功</span></span><br><span class="line"><span class="keyword">return</span> result.equals(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure>

<p>脚本执行中不能打断，加解锁必须有原子性。</p>
<p>4）使用开源框架Redisson</p>
<p>具体可参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangyingshuo/p/14510524.html?ivk_sa=1024320u">Redis实现分布式锁的7种方案</a></p>
<h4 id="ACL访问控制"><a href="#ACL访问控制" class="headerlink" title="ACL访问控制"></a>ACL访问控制</h4><p>redis6.0发布了权限管理功能ACL（access control list），可以对不同的用户设置不同的权限，限制用户可使用的命令，可访问的key等。</p>
<h5 id="acl命令"><a href="#acl命令" class="headerlink" title="acl命令"></a>acl命令</h5><p>1）<code>acl list</code>，展示用户权限列表。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;user default on nopass ~* &amp;* +@all&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>default</code> 表示用户名，兼容以前的AUTH命令，如果执行AUTH命令时不写用户名，redis认为是在认证这个default用户</p>
<p><code>on</code> 表示已启用该用户，off表禁用</p>
<p><code>nopass</code> 表示没有密码</p>
<p><code>~*</code> 表示可访问全部的数据Key</p>
<p><code>&amp;*</code> 表示允许用户访问所有Pub&#x2F;Sub频道</p>
<p><code>+@all</code> 表示用户的权限, “+”添加权限；”-“删减权限；@为redis命令分类； 可以通过 ACL CAT 查询相关分类，all表全部的命令集合，最终 +@all 表示拥有所有命令集合的所有权限</p>
<p>2）查看用户</p>
<p><code>acl users</code></p>
<p><code>acl whoami</code>，查看当前用户</p>
<p>3）创建用户</p>
<p><code>acl setuser xxx</code></p>
<p>删除用户：<code>acl deluser xxx</code></p>
<p>4）启用禁用</p>
<p><code>acl setuser xxx on &gt;123456</code>，启用用户xxx并设置密码123456，取消密码&lt;123456。</p>
<p>5）获取命令集合</p>
<p><code>acl cat</code></p>
<p>6）增加或减少命令权限</p>
<p><code>acl setuser xxx  ~*  +@string</code>，表示添加string类型的所有命令，多个类型命令用空格隔开。</p>
<p>7）限制key的范围</p>
<p><code>ACL SETUSER user resetkeys ~mykey:*</code>，让用户 user 只对以 mykey: 开头的这些 key 有权限。</p>
<h5 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h5><p>以上设置都是保存在redis内存中，一旦重启，这些设置就会全部失效，想持久化保存ACL配置，要把ACL相关权限设置都保存到文件中。</p>
<p>1）在redis配置文件中设置要导出的ACL配置文件全路径名，ACL的配置文件名必须以.acl结尾。</p>
<p>2）执行 acl save，上述操作才会保存到该文件。</p>
<p>如果已经有了acl配置文件，直接加载到redis中生效。首先在redis配置文件中设置ACL配置文件全路径名，然后在redis终端上运行<code>acl load</code>命令即可。</p>
<p>详细参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cj_eryue/article/details/131401400">一文搞懂redis的用户权限管理（ACL）功能</a></p>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>Redis 性能测试是通过同时执行多个命令实现的。</p>
<p>redis 性能测试的基本命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark [option] [option value]</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：该命令是在 redis 的目录下执行的，而不是 redis 客户端的内部指令。</p>
<p>以下实例同时执行 10000 个请求来检测性能：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -h 127.0.0.1 -p 6379 -t <span class="built_in">set</span>,lpush -n 10000 -q</span><br><span class="line"></span><br><span class="line">SET: 146198.83 requests per second</span><br><span class="line">LPUSH: 145560.41 requests per second</span><br><span class="line"><span class="comment">#-t仅运行以逗号分隔的测试命令列表,-n指定请求数,-q强制退出 redis。仅显示 query/sec 值</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/%E7%BC%93%E5%AD%98%E4%B8%AD%E9%97%B4%E4%BB%B6/">缓存中间件</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/0126/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">SpringMVC入门</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">基础命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">五大基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2String"><span class="nav-number">2.1.</span> <span class="nav-text">字符串String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%97%E8%A1%A8List"><span class="nav-number">2.2.</span> <span class="nav-text">列表List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E5%90%88Set"><span class="nav-number">2.3.</span> <span class="nav-text">集合Set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%88%E5%B8%8CHash"><span class="nav-number">2.4.</span> <span class="nav-text">哈希Hash</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88Zset"><span class="nav-number">2.5.</span> <span class="nav-text">有序集合Zset</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.6.</span> <span class="nav-text">新数据类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="nav-number">4.</span> <span class="nav-text">发布与订阅</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jedis%E6%93%8D%E4%BD%9CRedis"><span class="nav-number">5.</span> <span class="nav-text">Jedis操作Redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#springboot%E6%95%B4%E5%90%88redis"><span class="nav-number">6.</span> <span class="nav-text">springboot整合redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">7.</span> <span class="nav-text">事务操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis-%E8%84%9A%E6%9C%AC"><span class="nav-number">8.</span> <span class="nav-text">Redis 脚本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">9.</span> <span class="nav-text">数据备份与恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD"><span class="nav-number">9.1.</span> <span class="nav-text">备份</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="nav-number">9.2.</span> <span class="nav-text">恢复数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#bgsave"><span class="nav-number">9.3.</span> <span class="nav-text">bgsave</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">9.4.</span> <span class="nav-text">持久化的三种方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">10.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="nav-number">10.1.</span> <span class="nav-text">一主二从</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E4%BB%A3%E7%9B%B8%E4%BC%A0"><span class="nav-number">10.2.</span> <span class="nav-text">代代相传</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8Fsentinel"><span class="nav-number">10.3.</span> <span class="nav-text">哨兵模式sentinel</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E9%9B%86%E7%BE%A4"><span class="nav-number">11.</span> <span class="nav-text">redis集群</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="nav-number">11.1.</span> <span class="nav-text">集群搭建</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="nav-number">11.2.</span> <span class="nav-text">查询集群中的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="nav-number">11.3.</span> <span class="nav-text">故障恢复</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Jedis%E6%93%8D%E4%BD%9C%E9%9B%86%E7%BE%A4"><span class="nav-number">11.4.</span> <span class="nav-text">Jedis操作集群</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-number">12.</span> <span class="nav-text">应用问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">12.1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">12.2.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">12.3.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">12.4.</span> <span class="nav-text">分布式锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ACL%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">13.</span> <span class="nav-text">ACL访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#acl%E5%91%BD%E4%BB%A4"><span class="nav-number">13.1.</span> <span class="nav-text">acl命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="nav-number">13.2.</span> <span class="nav-text">持久化配置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="nav-number">14.</span> <span class="nav-text">性能测试</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/friends" class="mobile-nav-link">Friends</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2020-2024 沧海一粟 All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/main.js"></script>








  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
